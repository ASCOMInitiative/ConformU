@page "/"
@implements IDisposable
@using System.Threading
@inject IResizeListener listener
@inject ConformLogger conformLogger
@inject ConformConfiguration settings
@inject IJSRuntime JS
@using Microsoft.Extensions.Configuration
@inject IConfiguration Configuration
@* Radzen notification service to enable pop-up alerts *@
@inject NotificationService notificationService

<div>
    <h1>Welcome to Conform Universal!</h1>
    <div>
        <RadzenButton Id="StartButton" Click=@(args => StartTest("Starting test")) Text="Start" Icon="account_circle" Style="margin-bottom: 20px; width: 150px" />
        <RadzenButton Click=@(args => StopTest("Stopping test")) Text="Stop" Icon="account_circle" Style="margin-bottom: 20px; width: 150px" />
        <RadzenTextBox Id="Status" Style="width: 50em; margin-left: 40px;" @bind-Value=@statusMessage />
    </div>

    @*<div style="resize:none; overflow: auto;">*@

    <h4>Conform Log</h4>
    <RadzenTextArea Id="ConformLog" Style="line-height:1.3;" Name="ScreenLog" @bind-Value=@screenLog Rows="@screenLogRows" Cols="250" ReadOnly=true />

    @*Rows="@screenLogRows"*@

    @*</div>*@
</div>

@code {

    int screenLogRows = 10;
    string screenLog = "Conform log.";
    object screenLogLockObject = new object();
    object statusLockObject = new object();
#if WINDOWS7_0_OR_GREATER
    string statusMessage = "Windows Build";
#else
    string statusMessage = "Linux build";
#endif
    ConformanceTestManager tester;

    // Task and cancellation support
    Task conformanceTest;
    CancellationTokenSource cancellationTokenSource;
    CancellationToken cancelConformToken;

    protected override void OnInitialized()
    {
    }

    async void StartTest(string buttonName)
    {
        // Validate the supplied configuraiton and only start if there are no settings issues
        string validationMessage = settings.Validate();
        if (!string.IsNullOrEmpty(validationMessage)) // There is a configuraiton issue so present an error message
        {
            // Find the current position of the start button in the viewport
            BoundingClientRectangle result = await JS.InvokeAsync<BoundingClientRectangle>("GetBoundingClientRect", "StartButton");
            int x = (int)(result.Left);
            int y = (int)(result.Top) + 100;

            // Display the error message left aligned and below the start button
            ShowNotification(new NotificationMessage { Style = $"position: fixed; left: {x}px; top:{y}px;", Severity = NotificationSeverity.Error, Summary = "Test Device", Detail = $"Cannot start test: {validationMessage}", Duration = 4000 });

            return;
        }

        // Setting have validated OK so start the test

        // Create a task cancellation token source and cancellation token
        cancellationTokenSource = new CancellationTokenSource();
        cancelConformToken = cancellationTokenSource.Token;

        // Create a test manager instance to oversee the test
        tester = new ConformanceTestManager(settings, conformLogger, cancelConformToken);
        tester.OutputChanged += OutputChanged;
        tester.StatusChanged += StatusChanged;

        // Clear the screen log
        screenLog = "";

        // Create a task to run the conformance test
        conformanceTest = new Task(() =>
        {
            try
            {
                tester.TestDevice();
            }
            catch (Exception ex)
            {
                LogMsg("StartTest", $"Exception: \r\n {ex}");

            }

        }, cancelConformToken);

        // Start the conformnance test task
        conformanceTest.Start();

        // Execute this continuation task when the conformance test finishes to ensure that the tester is disposed even when the conformance task itself is cancelled.
        await conformanceTest.ContinueWith(antecedent =>
        {
            tester.Dispose(); // Dispose of the tester
            tester = null;
            JS.InvokeVoidAsync("ScrollToBottom", "ConformLog");

            GC.Collect();
        });
    }

    void StopTest(string buttonName)
    {
        if (tester is not null)
        {
            LogMsg("StopClick", $"STOPPING TESTER");
            cancellationTokenSource.Cancel(); // Cancel the Conform run
        }
    }

    /// <summary>
    /// Log a message to the screen and trace log
    /// </summary>
    /// <param name="id"></param>
    /// <param name="message"></param>
    void LogMsg(string id, string message)
    {
        conformLogger.LogMessage(id, message);
        screenLog += $"{(id).PadRight(30)} {message}\r\n";  // Add the new log message to the screen display
        SetScreenLogRows();
        InvokeAsync(StateHasChanged); // Display the updated log on the screen
    }

    async void SetScreenLogRows()
    {
        // Find the current position of the Conform log text area in the viewport
        BoundingClientRectangle result = await JS.InvokeAsync<BoundingClientRectangle>("GetBoundingClientRect", "ConformLog");
        int x = (int)(result.Left);
        int y = (int)(result.Top) + 100;

        //screenLogRows = (int)((browser.Height - result.Top) / 20);
        //conformLogger.LogMessage("SetScreenLogRows", $"Browserheight: {browser.Height}, LogAreaTop: {result.Top}, LogAreaHeight: {result.Height}, ScreenLogRows: {screenLogRows}");

        int crCount = screenLog.Count((f) => f == (char)10);

        int heightCount = Convert.ToInt32(((double)browser.Height - 200.0) / 20.0) + (browser.Height / 300) - 1;

        //screenLogRows = Math.Min(crCount, heightCount);
        screenLogRows = heightCount;
        //conformLogger.LogMessage("SetScreenLogRows", $"screenLogRows: {screenLogRows}");
    }

    /// <summary>
    /// Event handler for messages returned from the tester
    /// </summary>
    /// <param name="source"></param>
    /// <param name="e"></param>
    async public void OutputChanged(object sender, MessageEventArgs e)
    {
        lock (screenLogLockObject)
        {
            screenLog += $"{e.Message}\r\n";  // Add the new log message to the screen display
            SetScreenLogRows();
            InvokeAsync(StateHasChanged); // Display the updated log on the screen - invoke required because this event handler method could be called by any thread
        }
        await JS.InvokeVoidAsync("ScrollToBottom", "ConformLog");
    }

    /// <summary>
    /// Event handler for messages returned from the tester
    /// </summary>
    /// <param name="source"></param>
    /// <param name="e"></param>
    public void StatusChanged(object sender, MessageEventArgs e)
    {
        lock (statusLockObject)
        {
            statusMessage = $"{e.Message}";  // Add the new log message to the screen display

            InvokeAsync(StateHasChanged); // Display the updated log on the screen - invoke required because this event handler method could be called by any thread
        }
    }


    #region Log textarea - resize support

    BrowserWindowSize browser = new BrowserWindowSize();

    protected override void OnAfterRender(bool firstRender)
    {

        if (firstRender)
        {
            // Subscribe to the OnResized event. This will do work when the browser is resized.
            listener.OnResized += WindowResized;
        }
    }

    // This method will be called when the window resizes.
    // It is ONLY called when the user stops dragging the window's edge. (It is already throttled to protect your app from perf. nightmares)
    void WindowResized(object _, BrowserWindowSize window)
    {
        // Get the browsers's width / height
        browser = window;
        SetScreenLogRows();        // Log the new window size and number of rows
                                   // We're outside of the component's lifecycle, be sure to let it know it has to re-render.
                                   //conformLogger.LogMessage("WindowResized", $"Browser height: {browser.Height}, Browser width: {browser.Width}");


        StateHasChanged();
    }

    #endregion

    #region Dispose support

    void IDisposable.Dispose()
    {
        // Always use IDisposable in your component to unsubscribe from the event.
        // Be a good citizen and leave things how you found them.
        // This way event handlers aren't called when nobody is listening.
        listener.OnResized -= WindowResized;
    }

    #endregion
    private async void ShowNotification(NotificationMessage message)
    {
        notificationService.Notify(message);
        await InvokeAsync(() => { StateHasChanged(); });
    }

}
