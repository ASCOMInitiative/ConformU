@page "/"
@implements IDisposable
@using System.Threading
@inject IResizeListener listener
@inject ConformLogger conformLogger
@inject ConformConfiguration configuration
@inject IJSRuntime JS
@using Microsoft.Extensions.Configuration
@inject IConfiguration Configuration
@* Radzen notification service to enable pop-up alerts *@
@inject NotificationService notificationService

<div>
    <h1>Welcome to Conform Universal!</h1>
    <div>
        <RadzenButton Id="StartButton" Click=@(args => StartTest("Starting test")) Text="Start" Icon="account_circle" Style="margin-bottom: 20px; width: 150px" Disabled=@configuration.Settings.OperationInProgress />
        <RadzenButton Click=@(args => StopTest("Stopping test")) Text="Stop" Icon="account_circle" Style="margin-bottom: 20px; width: 150px" Disabled=@(!configuration.Settings.OperationInProgress) />
        <RadzenTextBox Id="Status" Style="width: 50em; margin-left: 40px;" @bind-Value=@statusMessage />
    </div>

    @*<div style="height:100%; max-height:100%">*@

    <h4>Conform Log</h4>
    <RadzenTextArea Id="ConformLog" Style="line-height:1.3;" Name="ScreenLog" @bind-Value=@screenLog Rows="@screenLogRows" Cols="250" ReadOnly=true />

    @*Rows="@screenLogRows"*@

    @*</div>*@
</div>

@code {
    private bool disposedValue;
    int screenLogRows = 10;
    string screenLog = "Conform log.";
    object screenLogLockObject = new object();
    object statusLockObject = new object();
#if WINDOWS7_0_OR_GREATER
    string statusMessage = "Windows Build";
#else
string statusMessage = "Linux build";
#endif
    ConformanceTestManager tester;

    // Task and cancellation support
    Task conformanceTest;
    CancellationTokenSource cancellationTokenSource;
    CancellationToken cancelConformToken;

    protected override void OnInitialized()
    {
        conformLogger.Debug = configuration.Settings.Debug;

    }

    async void StartTest(string buttonName)
    {
        try
        {
            // Set the operation in progress flag and refresh state throughout the page and navigation menu.
            configuration.Settings.OperationInProgress = true;
            configuration.RaiseConfigurationChangedEvent();
            StateHasChanged();

            // Validate the supplied configuraiton and only start if there are no settings issues
            string validationMessage = configuration.Validate();
            if (!string.IsNullOrEmpty(validationMessage)) // There is a configuraiton issue so present an error message
            {
                // Find the current position of the start button in the viewport
                BoundingClientRectangle result = await JS.InvokeAsync<BoundingClientRectangle>("GetBoundingClientRect", "StartButton");
                int x = (int)(result.Left);
                int y = (int)(result.Top) + 100;

                // Display the error message left aligned and below the start button
                ShowNotification(new NotificationMessage { Style = $"position: fixed; left: {x}px; top:{y}px;", Severity = NotificationSeverity.Error, Summary = "Test Device", Detail = $"Cannot start test: {validationMessage}", Duration = 4000 });

                return;
            }

            // Setting have validated OK so start the test

            // Create a task cancellation token source and cancellation token

            using (cancellationTokenSource = new CancellationTokenSource())
            {
                cancelConformToken = cancellationTokenSource.Token;

                // Create a test manager instance to oversee the test
                using (tester = new ConformanceTestManager(configuration, conformLogger, cancelConformToken))
                {
                    conformLogger.OutputChanged += OutputChanged;
                    conformLogger.StatusChanged += StatusChanged;
                    conformLogger.Debug = configuration.Settings.Debug;

                    // Clear the screen log
                    screenLog = "";

                    // Create a task to run the conformance test
                    conformanceTest = new Task(() =>
                    {
                        try
                        {
                            tester.TestDevice();
                        }
                        catch (Exception ex)
                        {
                            conformLogger.LogMessage("StartTest", MessageLevel.Info, $"Exception: \r\n {ex}");

                        }

                    }, cancelConformToken);
                    conformLogger.Log(ASCOM.Standard.Interfaces.LogLevel.Information, "Starting conformance test");
                    // Start the conformnance test task
                    conformanceTest.Start();
                    conformLogger.Log(ASCOM.Standard.Interfaces.LogLevel.Information, "Conformance test started OK");

                    // Wait for the task to complete.
                    conformLogger.Log(ASCOM.Standard.Interfaces.LogLevel.Information, "Awaiting conformance task completion");
                    await conformanceTest;
                    conformLogger.Log(ASCOM.Standard.Interfaces.LogLevel.Information, "Conformance task completed");

                    conformLogger.OutputChanged -= OutputChanged;
                    conformLogger.StatusChanged -= StatusChanged;
                }
            }
            conformLogger.Log(ASCOM.Standard.Interfaces.LogLevel.Information, "Awaiting Scroll to bottom");
            await JS.InvokeVoidAsync("ScrollToBottom", "ConformLog");
            conformLogger.Log(ASCOM.Standard.Interfaces.LogLevel.Information, "Scroll to bottom completed");

            GC.Collect();
        }
        catch (Exception ex)
        {
            try { conformLogger.LogMessage("INDEX.RAZOR-StartTest", MessageLevel.Error, $"{ex}"); } catch (Exception) { throw; }
            try { Console.WriteLine($"INDEX.RAZOR-StartTest Exception: {ex}"); } catch (Exception) { throw; }
        }
        finally
        {
            configuration.Settings.OperationInProgress = false;
            configuration.RaiseConfigurationChangedEvent();
            StateHasChanged();
        }
    }

    void StopTest(string buttonName)
    {
        if (tester is not null)
        {
            conformLogger.LogMessage("StopClick", MessageLevel.Info, $"STOPPING TESTER");
            cancellationTokenSource.Cancel(); // Cancel the Conform run
        }
    }

    async void SetScreenLogRows()
    {
        // Find the current position of the Conform log text area in the viewport
        BoundingClientRectangle result = await JS.InvokeAsync<BoundingClientRectangle>("GetBoundingClientRect", "ConformLog");
        int x = (int)(result.Left);
        int y = (int)(result.Top) + 100;

        //screenLogRows = (int)((browser.Height - result.Top) / 20);
        //conformLogger.LogMessage("SetScreenLogRows", $"Browserheight: {browser.Height}, LogAreaTop: {result.Top}, LogAreaHeight: {result.Height}, ScreenLogRows: {screenLogRows}");

        int crCount = screenLog.Count((f) => f == (char)10);

        int heightCount = Convert.ToInt32(((double)browser.Height - 200.0) / 20.0) + (browser.Height / 300) - 1;

        //screenLogRows = Math.Min(crCount, heightCount);
        screenLogRows = heightCount;
        //conformLogger.LogMessage("SetScreenLogRows", $"screenLogRows: {screenLogRows}");
    }

    /// <summary>
    /// Event handler for messages returned from the tester
    /// </summary>
    /// <param name="source"></param>
    /// <param name="e"></param>
    async public void OutputChanged(object sender, MessageEventArgs e)
    {
        lock (screenLogLockObject)
        {
            screenLog += $"{e.Message}\r\n";  // Add the new log message to the screen display
            SetScreenLogRows();
            InvokeAsync(StateHasChanged); // Display the updated log on the screen - invoke required because this event handler method could be called by any thread
        }
        await JS.InvokeVoidAsync("ScrollToBottom", "ConformLog");
    }

    /// <summary>
    /// Event handler for messages returned from the tester
    /// </summary>
    /// <param name="source"></param>
    /// <param name="e"></param>
    public void StatusChanged(object sender, MessageEventArgs e)
    {
        lock (statusLockObject)
        {
            statusMessage = $"{e.Message}";  // Add the new log message to the screen display

            InvokeAsync(StateHasChanged); // Display the updated log on the screen - invoke required because this event handler method could be called by any thread
        }
    }

    #region Log textarea - resize support

    BrowserWindowSize browser = new BrowserWindowSize();

    protected override void OnAfterRender(bool firstRender)
    {

        if (firstRender)
        {
            // Subscribe to the OnResized event. This will do work when the browser is resized.
            listener.OnResized += WindowResized;
        }
    }

    // This method will be called when the window resizes.
    // It is ONLY called when the user stops dragging the window's edge. (It is already throttled to protect your app from perf. nightmares)
    void WindowResized(object _, BrowserWindowSize window)
    {
        // Get the browsers's width / height
        browser = window;
        SetScreenLogRows();

        // Log the new window size and number of rows
        // We're outside of the component's lifecycle, be sure to let it know it has to re-render.
        //conformLogger.LogMessage("WindowResized", $"Browser height: {browser.Height}, Browser width: {browser.Width}");

        StateHasChanged();
    }

    #endregion

    #region Dispose support

    protected virtual void Dispose(bool disposing)
    {
        if (!disposedValue)
        {
            if (disposing)
            {
                Console.WriteLine("Index.Razor.Dispos() has been called...");
                listener.OnResized -= WindowResized;
            }

            disposedValue = true;
        }
    }

    public void Dispose()
    {
        // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
        Dispose(disposing: true);
        GC.SuppressFinalize(this);
    }

    #endregion

    private async void ShowNotification(NotificationMessage message)
    {
        notificationService.Notify(message);
        await InvokeAsync(() => { StateHasChanged(); });
    }

}
