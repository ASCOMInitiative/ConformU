@page "/"
@implements IDisposable
@using System.Threading
@inject BrowserResizeService listener
@inject ConformLogger conformLogger
@inject ConformConfiguration configuration
@inject IJSRuntime JS
@using Microsoft.Extensions.Configuration
@inject IConfiguration Configuration
@* Radzen notification service to enable pop-up alerts *@
@inject NotificationService notificationService

    <h1 style="display: @statusVisible">Welcome to Conform Universal!</h1>
    <div>

        <RadzenButton Id="StartButton" Click=@(args => StartTest("Starting test")) Text="Start" Style="margin-bottom: 20px; margin-right: 20px; width: 150px" Disabled=@configuration.Settings.OperationInProgress />
        <RadzenButton Click=@(args => StopTest("Stopping test")) Text="Stop" Style="margin-bottom: 20px; width: 150px" Disabled=@(!configuration.Settings.OperationInProgress) />
    </div>
<div style="display :@statusVisible">
    <RadzenTextBox Id="Status" Style="width: 100%; margin-bottom:20px; margin-right:20px" @bind-Value=@statusMessage />
</div>

<h4>Conform Log</h4>
<RadzenTextArea Id="ConformLog" Style="line-height: 18px; padding-bottom: 0px" Name="ScreenLog" @bind-Value=@screenLog Rows="@screenLogRows" Cols="250" ReadOnly=true />

@code {
    private string statusVisible = "initial";
    private bool disposedValue;
    int screenLogRows = 10;
    string screenLog = "Conform log.";
    object screenLogLockObject = new object();
    object statusLockObject = new object();
#if WINDOWS7_0_OR_GREATER
    string statusMessage = "Windows Build";
#else
    string statusMessage = "Linux build";
#endif
    ConformanceTestManager tester;

    // Task and cancellation support
    Task conformanceTest;
    CancellationTokenSource cancellationTokenSource;
    CancellationToken cancelConformToken;

    protected override void OnInitialized()
    {
        conformLogger.Debug = configuration.Settings.Debug;
        configuration.UiHasChanged += OnUiHasChanged;
    }

    public void OnUiHasChanged(object sender, EventArgs e)
    {
        ResizeLogWindow();
    }


    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            // Subscribe to the OnResized event. This will do work when the browser is resized.
            listener.Init(JS);
            listener.OnResize += WindowResized;
            ResizeLogWindow();
        }
    }

    async void StartTest(string buttonName)
    {
        try
        {
            // Set the operation in progress flag and refresh state throughout the page and navigation menu.
            configuration.Settings.OperationInProgress = true;
            configuration.RaiseUiHasChangedEvent();
            StateHasChanged();

            // Validate the supplied configuraiton and only start if there are no settings issues
            string validationMessage = configuration.Validate();
            if (!string.IsNullOrEmpty(validationMessage)) // There is a configuraiton issue so present an error message
            {
                // Find the current position of the start button in the viewport
                BoundingClientRectangle result = await JS.InvokeAsync<BoundingClientRectangle>("GetBoundingClientRect", "StartButton");
                int x = (int)(result.Left);
                int y = (int)(result.Top) + 100;

                // Display the error message left aligned and below the start button
                ShowNotification(new NotificationMessage { Style = $"position: fixed; left: {x}px; top:{y}px;", Severity = NotificationSeverity.Error, Summary = "Test Device", Detail = $"Cannot start test: {validationMessage}", Duration = 4000 });

                return;
            }

            // Setting have validated OK so start the test

            // Create a task cancellation token source and cancellation token

            using (cancellationTokenSource = new CancellationTokenSource())
            {
                cancelConformToken = cancellationTokenSource.Token;

                // Create a test manager instance to oversee the test
                using (tester = new ConformanceTestManager(configuration, conformLogger, cancelConformToken))
                {
                    try
                    {
                        conformLogger.MessageLogChanged += OutputChanged;
                        conformLogger.StatusChanged += StatusChanged;
                        conformLogger.Debug = configuration.Settings.Debug;

                        // Clear the screen log
                        screenLog = "";

                        // Create a task to run the conformance test
                        conformanceTest = new Task(() =>
                        {
                            try
                            {
                                tester.TestDevice();
                            }
                            catch (Exception ex)
                            {
                                conformLogger.LogMessage("StartTest", MessageLevel.Error, $"Exception: \r\n {ex}");

                            }

                        }, cancelConformToken);
                        conformLogger.LogMessage("StartTest", MessageLevel.Debug, "Starting conformance test");
                        // Start the conformnance test task
                        conformanceTest.Start();
                        conformLogger.LogMessage("StartTest", MessageLevel.Debug, "Conformance test started OK");

                        // Wait for the task to complete.
                        conformLogger.LogMessage("StartTest", MessageLevel.Debug, "Awaiting conformance task completion");
                        await conformanceTest;
                        conformLogger.LogMessage("StartTest", MessageLevel.Debug, "Conformance task completed");
                    }
                    finally
                    {
                        conformLogger.MessageLogChanged -= OutputChanged;
                        conformLogger.StatusChanged -= StatusChanged;
                    }
                }
            }
            conformLogger.LogMessage("StartTest", MessageLevel.Debug, "Awaiting Scroll to bottom");
            await JS.InvokeVoidAsync("ScrollToBottom", "ConformLog");
            conformLogger.LogMessage("StartTest", MessageLevel.Debug, "Scroll to bottom completed");

            GC.Collect();
        }
        catch (Exception ex)
        {
            try { conformLogger.LogMessage("INDEX.RAZOR-StartTest", MessageLevel.Error, $"{ex}"); } catch (Exception) { throw; }
            try { Console.WriteLine($"INDEX.RAZOR-StartTest Exception: {ex}"); } catch (Exception) { throw; }
        }
        finally
        {
            configuration.Settings.OperationInProgress = false;
            configuration.RaiseUiHasChangedEvent();
            StateHasChanged();
            await JS.InvokeVoidAsync("ScrollToBottom", "ConformLog");
        }
    }

    void StopTest(string buttonName)
    {
        if (tester is not null)
        {
            conformLogger.LogMessage("StopClick", MessageLevel.Info, $"STOPPING TESTER");
            cancellationTokenSource.Cancel(); // Cancel the Conform run
        }
    }

    /// <summary>
    /// Event handler for messages returned from the tester
    /// </summary>
    /// <param name="source"></param>
    /// <param name="e"></param>
    async public void OutputChanged(object sender, MessageEventArgs e)
    {
        lock (screenLogLockObject)
        {
            screenLog += $"{e.Message}\r\n";  // Add the new log message to the screen display
        }
        await InvokeAsync(StateHasChanged);
        await JS.InvokeVoidAsync("ScrollToBottom", "ConformLog");
    }

    /// <summary>
    /// Event handler for messages returned from the tester
    /// </summary>
    /// <param name="source"></param>
    /// <param name="e"></param>
    public void StatusChanged(object sender, MessageEventArgs e)
    {
        lock (statusLockObject)
        {
            statusMessage = $"{e.Message}";  // Add the new log message to the screen display

            InvokeAsync(StateHasChanged); // Display the updated log on the screen - invoke required because this event handler method could be called by any thread
        }
    }

    #region Log textarea - resize support

    async void ResizeLogWindow()
    {
        BoundingClientRectangle browserWindowSize = await JS.InvokeAsync<BoundingClientRectangle>("GetBoundingWindowRect");
        BrowserWindowSize blazorProWindowSize = new();
        blazorProWindowSize.Width = (int)browserWindowSize.Width;
        blazorProWindowSize.Height = (int)browserWindowSize.Height;

        //conformLogger.LogMessage("ResizeLogWindow", MessageLevel.Debug, $"Width: {blazorProWindowSize.Width}, Height: {blazorProWindowSize.Height}");
        WindowResized(new object(), blazorProWindowSize);
        //conformLogger.LogMessage("ResizeLogWindow", MessageLevel.Debug, $"Method completed");
    }

    // This method will be called when the window resizes.
    // It is ONLY called when the user stops dragging the window's edge. (It is already throttled to protect your app from perf. nightmares)
    async void WindowResized(object _, BrowserWindowSize window)
    {
        try
        {
            // Get the browsers's width / height
            // Find the current position of the Conform log text area in the viewport
            BoundingClientRectangle result = await JS.InvokeAsync<BoundingClientRectangle>("GetBoundingClientRect", "ConformLog");
            if (result is not null)
            {
                screenLogRows = Convert.ToInt32(((Convert.ToDouble(window.Height) - result.Top) / 18.0)) - 2;

                // Hide the status field at small heights
                if (window.Height < 600) statusVisible = "none";
                else statusVisible = "initial";

                string browser = "";
                browser = await JS.InvokeAsync<string>(identifier: "IdentifyBrowser");

                if (browser.Contains("Firefox", StringComparison.InvariantCultureIgnoreCase)) screenLogRows -= 1;

                //conformLogger.LogMessage("SetScreenLogRows", MessageLevel.Debug, $"Window width: {window.Width}, Window.height: {window.Height}, LogTop: {result.Top}, LogHeight: {result.Height}, ScreenLogRows: {screenLogRows}, Browser: {browser}");
                await InvokeAsync(StateHasChanged); // Display the updated log on the screen - invoke required because this event handler method could be called by any thread
            }

            else
            {
                conformLogger.LogMessage("SetScreenLogRows", MessageLevel.Debug, $"BoundingClientRectangle is NULL - No action taken.");
            }
        }
        catch (Exception ex)
        {
            conformLogger.LogMessage("SetScreenLogRows", $"Exception: \r\n{ex}");
        }
    }

    #endregion

    #region Dispose support

    protected virtual void Dispose(bool disposing)
    {
        if (!disposedValue)
        {
            if (disposing)
            {
                listener.OnResize -= WindowResized;
                configuration.UiHasChanged -= OnUiHasChanged;
            }

            disposedValue = true;
        }
    }

    public void Dispose()
    {
        // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
        Dispose(disposing: true);
        GC.SuppressFinalize(this);
    }

    #endregion

    private async void ShowNotification(NotificationMessage message)
    {
        notificationService.Notify(message);
        await InvokeAsync(() => { StateHasChanged(); });
    }

}
