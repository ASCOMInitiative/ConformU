@page "/"
@implements IDisposable
@using System.Threading
@inject IResizeListener listener
@inject ConformLogger conformLogger
@inject ConformConfiguration settings
@inject IJSRuntime JS
@* Radzen notification service to enable pop-up alerts *@
@inject NotificationService notificationService

<div>
    <h1>Welcome to Conform Universal!</h1>
    <div>
        <RadzenButton Id="StartButton" Click=@(args => StartTest("Starting test")) Text="Start" Icon="account_circle" Style="margin-bottom: 20px; width: 150px" />
        <RadzenButton Click=@(args => StopTest("Stopping test")) Text="Stop" Icon="account_circle" Style="margin-bottom: 20px; width: 150px" />
    </div>

    <h4>Conform Log</h4>
    <RadzenTextArea Id="ConformLog" Style="line-height:1.3" Name="ScreenLog" @bind-Value=@screenLog Rows="@Rows" Cols="250" ReadOnly=true />
</div>

@code {

    int Rows = 10;
    string screenLog;
    object screenLoglockObject = new object();

    DeviceConformanceTester tester;

    // Task and cancellation support
    Task conformanceTest;
    Task waitForTestCompletion;
    CancellationTokenSource cancellationTokenSource;
    CancellationToken cancelConformToken;

    protected override void OnInitialized()
    {
    }

    async void StartTest(string buttonName)
    {

        // Validate the supplied configuraiton and only start if there are no settings issues
        string validationMessage = settings.Validate();
        if (!string.IsNullOrEmpty(validationMessage)) // There is a configuraiton issue so present an error message
        {
            // Find the current position of the start button in the viewport
            BoundingClientRectangle result = await JS.InvokeAsync<BoundingClientRectangle>("GetBoundingClientRect", "StartButton");
            int x = (int)(result.Left);
            int y = (int)(result.Top) + 100;

            // Display the error message left aligned and below the start button
            ShowNotification(new NotificationMessage { Style = $"position: fixed; left: {x}px; top:{y}px;", Severity = NotificationSeverity.Error, Summary = "Test Device", Detail = $"Cannot start test: {validationMessage}", Duration = 4000 });

            return;
        }

        // Create a task cancellation token source and cancellation token
        cancellationTokenSource = new CancellationTokenSource();
        cancelConformToken = cancellationTokenSource.Token;

        // Setting have validated OK so start the test
        LogMsg("WarningMessageDisplayed", settings.Settings.WarningMessageDisplayed.ToString());
        LogMsg("UpdateDate", settings.Settings.UpdateDate.ToString());
        LogMsg("DisplayMethodCalls", settings.Settings.DisplayMethodCalls.ToString());
        LogMsg("Telescope", settings.Settings.DeviceTelescope.ToString());
        LogMsg("CurrentDeviceType", settings.Settings.CurrentDeviceType);

        LogMsg("StartTest", $"Creating TASK");
        tester = new DeviceConformanceTester(settings, cancelConformToken, conformLogger);
        tester.OutputChanged += TesterChanged;
        conformanceTest = new Task(() =>
        {
            try
            {
                tester.TestDevice();
            }
            catch (Exception ex)
            {
                LogMsg("StartTest", $"Exception: \r\n {ex}");

            }
            LogMsg("StartTest", $"Test FINISHED");
            tester.Dispose(); // Dispose of the tester
            tester = null;
            LogMsg("StartTest", $"Tester disposed");

            GC.Collect();
        }, cancelConformToken);

        LogMsg("StartTest", $"Starting TASK");
        conformanceTest.Start();
        LogMsg("StartTest", $"TASK started");

    }

    void StopTest(string buttonName)
    {
        LogMsg("StopClick", $"STOPPING TESTER");

        if (tester is not null)
        {
            LogMsg("StopClick", $"Setting cancellation token");
            cancellationTokenSource.Cancel(); // Cancel the Conform run
        }
    }

    /// <summary>
    /// Log a message to the screen and trace log
    /// </summary>
    /// <param name="id"></param>
    /// <param name="message"></param>
    void LogMsg(string id, string message)
    {
        conformLogger.LogMessage(id, message);
        screenLog += $"{(id).PadRight(30)} {message}\r\n";  // Add the new log message to the screen display
        InvokeAsync(StateHasChanged); // Display the updated log on the screen
    }

    /// <summary>
    /// Event handler for messages returned from the tester
    /// </summary>
    /// <param name="source"></param>
    /// <param name="e"></param>
    async public void TesterChanged(object sender, MessageEventArgs e)
    {
        lock (screenLoglockObject)
        {
            screenLog += $"{e.Message}\r\n";  // Add the new log message to the screen display

            InvokeAsync(StateHasChanged); // Display the updated log on the screen
        }
        await JS.InvokeVoidAsync("ScrollToBottom", "ConformLog");
    }

    #region Log textarea - resize support

    BrowserWindowSize browser = new BrowserWindowSize();

    protected override void OnAfterRender(bool firstRender)
    {

        if (firstRender)
        {
            // Subscribe to the OnResized event. This will do work when the browser is resized.
            listener.OnResized += WindowResized;
        }
    }

    // This method will be called when the window resizes.
    // It is ONLY called when the user stops dragging the window's edge. (It is already throttled to protect your app from perf. nightmares)
    void WindowResized(object _, BrowserWindowSize window)
    {
        // Get the browsers's width / height
        browser = window;

        // Calculate the number of rows
        Rows = Convert.ToInt32(((double)browser.Height - 200) / 20.0) + (browser.Height / 300) - 1;

        // Log the new window size and number of rows
        LogMsg("WindowResized", $"Height: {browser.Height}, Rows: {Rows}");

        // We're outside of the component's lifecycle, be sure to let it know it has to re-render.
        StateHasChanged();
    }

    #endregion

    #region Dispose support

    void IDisposable.Dispose()
    {
        // Always use IDisposable in your component to unsubscribe from the event.
        // Be a good citizen and leave things how you found them.
        // This way event handlers aren't called when nobody is listening.
        listener.OnResized -= WindowResized;
    }

    #endregion
    private async void ShowNotification(NotificationMessage message)
    {
        notificationService.Notify(message);
        await InvokeAsync(() => { StateHasChanged(); });
    }

}
