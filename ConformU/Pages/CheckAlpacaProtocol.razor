@page "/CheckAlpacaProtocol"

@implements IDisposable
@using System.Threading;

@inject ConformLogger logger
@inject ConformConfiguration configuration
@inject ConformStateManager state
@inject BrowserResizeService listener
@inject IJSRuntime JS
@inject NotificationService notificationService

<h2>Check Alpaca Protocol</h2>

<div>
    <RadzenButton Id="testButton" Click=@(() => StartCheckAlpacaProtocol()) Text="Check Protocol" Style="margin-bottom: 20px; margin-right: 20px; width: 150px" IsBusy=@settings.OperationInProgress Disabled=@(configuration.Settings.DeviceTechnology!=DeviceTechnology.Alpaca) />
    <RadzenButton Id="StopButton" Click=@(async () => await StopTest()) Text="Stop" Style="margin-bottom: 20px; margin-right: 40px; width: 150px" Disabled=@(!configuration.Settings.OperationInProgress) />
    <span style="white-space:nowrap">
        <RadzenLabel Text="Status:" Component="TESTSTATUS" Style="margin-right:2px;margin-top:0px; color:#0366d6;font-weight:bold" />
        <RadzenTextBox Name="TESTSTATUS" Placeholder="" @bind-Value=@statusText ReadOnly=true Style="width:600px;font-weight:bold;margin-right:40px;margin-bottom:10px" />
    </span>
</div>
<RadzenTextArea Id="ProtocolLog" Style="line-height: 18px; padding-bottom: 0px" Name="ProtocolLogName" @bind-Value=@screenLog Rows="@screenLogRows" @bind-Cols=@screenLogColumns ReadOnly=true />

@code
{
    private bool disposedValue;

    AlpacaProtocolTestManager tester;
    Task<int> conformanceTestTask;

    readonly object screenLogLockObject = new object();
    readonly object statusLockObject = new object();

    // Cancellation management
    CancellationTokenSource applicationCancellationTokenSource;
    CancellationToken applicationCancellationToken;

    string screenLog = "";
    int screenLogRows;
    int screenLogColumns;
    string statusText;
    ConformU.Settings settings;

    internal enum TestOutcome
    {
        OK,
        Info,
        Issue,
        Error
    }

    #region Blazor lifetime event handlers

    protected override void OnInitialized()
    {
        state.UiHasChanged += OnUiHasChanged;
        settings = configuration.Settings;
        StartCheckAlpacaProtocol();
        applicationCancellationTokenSource = new CancellationTokenSource();
        applicationCancellationToken = applicationCancellationTokenSource.Token;
    }

    protected override async void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            // Subscribe to the OnResized event. This will do work when the browser is resized.
            listener.Init(JS);
            listener.OnResize += WindowResized;
            await ResizeLogWindow();
        }
    }

    #endregion

    #region Alpaca protocol test management

    /// <summary>
    /// Stop a running test
    /// </summary>
    private async Task StopTest()
    {
        await Task.Run(() =>
        {
            LogBlankLine();
            LogLine($"STOP button pressed... stopping tests");
            LogBlankLine();
            applicationCancellationTokenSource.Cancel();
        });
    }

    async void StartCheckAlpacaProtocol()
    {
        int numberOfErrosAndIssue = -99990;

        try
        {
            // Set the operation in progress flag and refresh state throughout the page and navigation menu.
            configuration.Settings.OperationInProgress = true;
            state.RaiseUiHasChangedEvent();
            StateHasChanged();

            // Validate the supplied configuration and only start if there are no settings issues
            string validationMessage = configuration.Validate();
            if (!string.IsNullOrEmpty(validationMessage)) // There is a configuration issue so present an error message
            {
                // Find the current position of the start button in the viewport
                BoundingClientRectangle result = await JS.InvokeAsync<BoundingClientRectangle>("GetBoundingClientRect", "StartButton");
                int x = (int)(result.Left);
                int y = (int)(result.Top) + 100;

                // Display the error message left aligned and below the start button
                ShowNotification(new NotificationMessage { Style = $"position: fixed; left: {x}px; top:{y}px;", Severity = NotificationSeverity.Error, Summary = "Test Device", Detail = $"Cannot start test: {validationMessage}", Duration = 4000 });

                return;
            }

            // Setting have validated OK so start the test

            // Create a task cancellation token source and cancellation token

            using (applicationCancellationTokenSource = new CancellationTokenSource())
            {
                applicationCancellationToken = applicationCancellationTokenSource.Token;

                // Create a test manager instance to oversee the test
                using (tester = new AlpacaProtocolTestManager(configuration, logger, applicationCancellationTokenSource, applicationCancellationToken))
                {
                    try
                    {
                        logger.MessageLogChanged += OutputChanged;
                        logger.StatusChanged += StatusChanged;
                        logger.Debug = configuration.Settings.Debug;

                        // Clear the screen log
                        screenLog = "";

                        // Add a blank line to the console log
                        Console.WriteLine("");

                        // Create a task to run the conformance test
                        conformanceTestTask = new Task<int>(() =>
                        {
                            int returnCode = -99997;
                            try
                            {
                                logger.LogMessage("StartTest", MessageLevel.Debug, "Before TestAlpacaProtocol method");
                                returnCode = tester.TestAlpacaProtocol().Result;
                                logger.LogMessage("StartTest", MessageLevel.Debug, $"After TestAlpacaProtocol method - Return code: {returnCode}");
                            }
                            catch (Exception ex)
                            {
                                logger.LogMessage("StartTest", MessageLevel.Error, $"Exception: \r\n {ex}");
                                returnCode= -99998;
                            }
                            return returnCode;
                        }, applicationCancellationToken);

                        // Start the conformance test task
                        logger.LogMessage("StartTest", MessageLevel.Debug, "Starting conformance test");
                        conformanceTestTask.Start();
                        logger.LogMessage("StartTest", MessageLevel.Debug, "Conformance test started OK");

                        // Wait for the task to complete.
                        logger.LogMessage("StartTest", MessageLevel.Debug, "Awaiting conformance task completion");
                        await conformanceTestTask;
                        numberOfErrosAndIssue= conformanceTestTask.Result;
                        logger.LogMessage("StartTest", MessageLevel.Debug, $"Conformance task completed. Number of issues and errors: {numberOfErrosAndIssue}");

                        tester.Dispose();
                    }
                    finally
                    {
                        logger.MessageLogChanged -= OutputChanged;
                        logger.StatusChanged -= StatusChanged;
                    }
                }
            }
            await JS.InvokeVoidAsync("ScrollToBottom", "ProtocolLog");
            logger.LogMessage("StartTest", MessageLevel.Debug, "Scroll to bottom completed");

            GC.Collect();
        }
        catch (Exception ex)
        {
            try { logger.LogMessage("INDEX.RAZOR-StartTest", MessageLevel.Error, $"{ex}"); } catch (Exception) { throw; }
            try { Console.WriteLine($"INDEX.RAZOR-StartTest Exception: {ex}"); } catch (Exception) { throw; }
        }
        finally
        {
            configuration.Settings.OperationInProgress = false;
            state.RaiseUiHasChangedEvent();
            StateHasChanged();
            try
            {
                await JS.InvokeVoidAsync("ScrollToBottom", "ProtocolLog");

            }
            catch { }
        }
    }

    /// <summary>
    /// Start an Alpaca protocol check
    ///</summary>
    internal void StartCheckAlpacaProtocolOriginal()
    {
        try
        {
            // Create a new application cancellation token
            applicationCancellationTokenSource = new CancellationTokenSource();
            applicationCancellationToken = applicationCancellationTokenSource.Token;

            // Clear the screen
            ClearLogScreen();

            // Make sure we only test Alpaca devices
            if (configuration.Settings.DeviceTechnology == DeviceTechnology.Alpaca)
            {
                //Initialise Status field
                SetStatus("Testing for Alpaca protocol violations...");

                // Start the task to run the Alpaca protocol test
                LogText("StartCheckAlpacaProtocol", $"Starting check...");
                LogBlankLine();

                // Start the test
                //Task.Run(async () => { await TestAlpacaProtocol(); });
            }
            else
            {
                //Initialise Status field
                SetStatus("Selected device is not an Alpaca device");
            }
        }
        catch (Exception ex)
        {
            LogMessage("StartCheckAlpacaProtocol", TestOutcome.Error, $"Exception: {ex}");
        }
    }

    #endregion

    #region Logging and window resize

    /// <summary>
    /// Clear the log window
    ///    </summary>
    private void ClearLogScreen()
    {
        screenLog = "";
    }

    /// <summary>
    /// Log a formatted message to the screen and log file
    ///</summary>
    ///<param name="method">Calling method name</param>
    ///    <param name = "message" > Message to log</param>
    ///    <param name = "padding" > Number of characters to which the message should be right padded</param>
    private async void LogMessage(string method, TestOutcome outcome, string message, string contextMessage = null)
    {
        string methodString, outcomeString;

        switch (outcome)
        {
            case TestOutcome.OK:
                outcomeString = "OK";
                break;

            case TestOutcome.Info:
                outcomeString = "INFO";
                break;

            case TestOutcome.Issue:
                outcomeString = "ISSUE";
                break;
            case TestOutcome.Error:
                outcomeString = "ERROR";
                break;

            default:
                throw new Exception($"Unknown test outcome type: {outcome}");
        }
        methodString = $"{method.PadRight(ExtensionMethods.COLUMN_WIDTH)}{outcomeString.PadRight(ExtensionMethods.OUTCOME_WIDTH)}";

        // Write to the logger
        logger?.LogMessage(methodString, message);
        if (contextMessage is not null) logger?.LogMessage("", contextMessage);

        // Reformat the text across multiple screen lines if the message does not contain HTML code. If it does contain HTML display as-is.
        screenLog = $"{screenLog}\r\n{methodString}{message.Trim(new char[] { ' ', '\r', '\n' })}";

        // Add the context message if present
        if (contextMessage is not null)
        {
            screenLog = screenLog + $"\r\n{new string(' ', ExtensionMethods.COLUMN_WIDTH + ExtensionMethods.OUTCOME_WIDTH)}  Response: {contextMessage}".TrimEnd(new char[] { '\r', '\n' });
        }

        try
        {
            await InvokeAsync(() => { StateHasChanged(); });
            await JS.InvokeVoidAsync("ScrollToBottom", "ProtocolLog");
        }
        catch { }
    }

    /// <summary>
    /// Log an unformatted message to the screen and log file
    /// </summary>
    /// <param name="method"></param>
    /// <param name="message"></param>
    private async void LogText(string method, string message)
    {
        logger?.LogMessage(method, message);
        screenLog = (screenLog + $"\r\n{message}").Trim(new char[] { '\r', '\n' });

        try
        {
            await InvokeAsync(() => { StateHasChanged(); });
            await JS.InvokeVoidAsync("ScrollToBottom", "ProtocolLog");
        }
        catch { }
    }

    /// <summary>
    /// Log a text line without additional formatting
    /// </summary>
    /// <param name="message"></param>
    private void LogLine(string message)
    {
        logger?.LogMessage(message, "");
        screenLog = $"{screenLog}\r\n{message}";
    }

    /// <summary>
    /// Add a blank line to the log
    ///    </summary>
    private void LogBlankLine()
    {
        screenLog += $"\r\n";
    }

    /// <summary>
    /// Set the status message
    ///    </summary>
    ///    <param name="message"></param>
    private async void SetStatus(string message)
    {
        statusText = message;
        await InvokeAsync(() => { StateHasChanged(); });
    }

    /// <summary>
    /// Make the log window fit the browser size
    ///    </summary>
    /// <returns></returns>
    async Task ResizeLogWindow()
    {
        try
        {
            BoundingClientRectangle browserWindowSize = await JS.InvokeAsync<BoundingClientRectangle>
                ("GetBoundingWindowRect");
            BrowserWindowSize blazorProWindowSize = new();
            blazorProWindowSize.Width = (int)browserWindowSize.Width;
            blazorProWindowSize.Height = (int)browserWindowSize.Height;

            //logger.LogMessage("ResizeLogWindow", MessageLevel.Debug, $"Width: {blazorProWindowSize.Width}, Height: {blazorProWindowSize.Height}");
            WindowResized(new object(), blazorProWindowSize);
            //logger.LogMessage("ResizeLogWindow", MessageLevel.Debug, $"Method completed");
        }
        catch { }
    }

    // This method will be called when the window resizes.
    // It is ONLY called when the user stops dragging the window's edge. (It is already throttled to protect your app from performance nightmares)
    async void WindowResized(object _, BrowserWindowSize window)
    {
        try
        {
            // Get the browsers's width / height
            // Find the current position of the Conform log text area in the viewport
            BoundingClientRectangle result = await JS.InvokeAsync<BoundingClientRectangle>("GetBoundingClientRect", "ProtocolLog");
            if (result is not null)
            {
                screenLogRows = Convert.ToInt32(((Convert.ToDouble(window.Height) - result.Top) / 18.0)) - 2;
                //screenLogColumns = Convert.ToInt32(Convert.ToDouble(result.Width) / (Globals.IsSmall(window.Width, window.Height) ? 8.4 : 9.3));
                screenLogColumns = Convert.ToInt32((Convert.ToDouble(result.Width) - 32.0) / (Globals.IsSmall(window.Width, window.Height) ? 8.4 : 8.482));
                // Hide the status field at small heights
                if (window.Height < 600)
                {
                    screenLogRows += 0;
                }
                else
                {

                }

                string browser = "";
                browser = await JS.InvokeAsync<string>(identifier: "IdentifyBrowser");

                if (browser.Contains("Firefox", StringComparison.InvariantCultureIgnoreCase)) screenLogRows -= 1;


                //logger.LogMessage("SetScreenLogRows", MessageLevel.Debug, $"Window width: {window.Width}, Window.height: {window.Height}, LogTop: {result.Top}, LogHeight: {result.Height}, ScreenLogRows: {screenLogRows}, Browser: {browser}");
                await InvokeAsync(StateHasChanged); // Display the updated log on the screen - invoke required because this event handler method could be called by any thread
            }

            else
            {
                logger.LogMessage("SetScreenLogRows", MessageLevel.Debug, $"BoundingClientRectangle is NULL - No action taken.");
            }
        }
        catch
        {
            // logger.LogMessage("SetScreenLogRows", $"Exception: \r\n{ex}");
        }
    }

    public async void OnUiHasChanged(object sender, EventArgs e)
    {
        try
        {
            await ResizeLogWindow();
        }
        catch (Exception ex)
        {
            logger.LogMessage("CheckAlpacaProtocol.OnUiHasChanged", MessageLevel.Error, $"Exception: {ex}.");
            throw;
        }
    }

    /// <summary>
    /// Event handler for messages returned from the tester
    /// </summary>
    /// <param name="source"></param>
    /// <param name="e"></param>
    public async void OutputChanged(object sender, MessageEventArgs e)
    {
        try
        {
            lock (screenLogLockObject)
            {
                screenLog += $"{e.Message}\r\n";  // Add the new log message to the screen display
            }
            await InvokeAsync(StateHasChanged);
            await JS.InvokeVoidAsync("ScrollToBottom", "ProtocolLog");
        }
        catch { }
    }

    /// <summary>
    /// Event handler for messages returned from the tester
    /// </summary>
    /// <param name="source"></param>
    /// <param name="e"></param>
    public void StatusChanged(object sender, MessageEventArgs e)
    {
        lock (statusLockObject)
        {
            SetStatus(e.Message);  // Add the new log message to the screen display

            InvokeAsync(StateHasChanged); // Display the updated log on the screen - invoke required because this event handler method could be called by any thread
        }
    }

    private async void ShowNotification(NotificationMessage message)
    {
        notificationService.Notify(message);
        await InvokeAsync(() => { StateHasChanged(); });
    }

    #endregion

    #region Dispose support

    protected virtual void Dispose(bool disposing)
    {
        if (!disposedValue)
        {
            if (disposing)
            {
                listener.OnResize -= WindowResized;
                state.UiHasChanged -= OnUiHasChanged;
            }

            disposedValue = true;
        }
    }

    public void Dispose()
    {
        // Do not change this code. Put clean-up code in 'Dispose(bool disposing)' method
        Dispose(disposing: true);
        GC.SuppressFinalize(this);
    }

    #endregion
}
